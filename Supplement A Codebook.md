# Supplement A Codebook

## 1. Baseline Analysis

►*Description and Relation to Android OS Upgrade Conflict*: The baseline analysis phase refers to the process in which the downstream receives the upstream code update branch and analyzes its own code and Google's code situation to prepare for the possible scenarios of the Android upgrade, including: code branch analysis and screening, conflict strategy merging, conflict scale prediction and other activities. In this phase, the development team scans the upstream and downstream code repositories after receiving Google code updates, analyzes the code changes in the upstream AOSP branch and the downstream branch, obtains possible architectural changes, and determines the appropriate Android upgrade strategy (forward upgrade, reverse upgrade, and merge upgrade), which has its own advantages and disadvantages, and prioritizes forward upgrade strategy, followed by merge upgrade strategy. In practice, the forward upgrade strategy is prioritized, followed by the merge upgrade strategy, and finally the reverse upgrade. Finally, the manager will combine historical data indicators and human experience to predict the cost of conflicts, and arrange a reasonable upgrade cycle and manpower to ensure that the upgrade quality is qualified within the expected time.

►*Challenges (Code, Description and Example)*:

- **Architecture Compatibility**. The intricacies of AOSP's architectural changes encompass deprecated, irreversible, and duplicated features, posing a challenge for downstream architectures to adapt. *Example:* "When Google updates the code architecture of a module, and the downstream module is custom developed based on the original architecture, since Google holds a dominant position over architecture, it does not allow us to change its architecture, only to do the adaptation."
- **Intense Upgrade Cycle.** Facing intense competition from peers and rapid Android Upgrade cycles, developers are under pressure to quickly identify AOSP architectural and code changes. *Example:* "Feeling nervous that the pace of upgrades is increasing every year." "Too fast a pace of upgrades may affect the accuracy of the merge."
- **Upgrade Strategy Decision.** It is challenging to determine the most suitable Android upgrade strategy, whether to adopt a forward, reverse, or merger upgrade。*Example:* “We will carefully consider appropriate upgrading strategies based on upstream and downstream code changes.”
- **Project TQC Prediction.** Before initiating the Android upgrade operations, it is imperative to anticipate not only the extent of merge conflicts, but also the upgrade cycle, upgrade quality, and potential cost investment. *Example:* "The project manager will utilize historical experience and project-level metrics such as number of critical issues, upgrade cycle time, and upgrade manpower to predict and measure the effectiveness of Android upgrades. Some metrics from academia will be considered for inclusion later."

## 2. Conflict Reason Analysis

►*Description and Relation to Android OS Upgrade Conflict*: The Conflict Reason Analysis phase refers to the stage where, after implementing a merging strategy, developers conduct an in-depth analysis of the causes of conflicts that arise during the upstream and downstream merging process of Android upgrades. Reviewing the root causes of these conflicts is crucial for developing effective solutions and reducing the occurrence of similar issues. During this phase, developers first need to identify the specific location of the conflicting code, typically by using version control systems or merging tools to locate the conflicts. Then, they review the commit history of both upstream and downstream changes, comparing and analyzing the code modifications and logical changes made by both parties. This process helps in understanding the intent behind each modification, thereby allowing for a thorough analysis of the fundamental reasons behind the conflicts.

►*Challenges (Code, Description and Example)*:

- **Rapid Iteration of the AOSP**. Upstream AOSP's frequent feature iterations, code refactoring, and updates made by Google trigger conflicts. *Example*: "Google’s frequent internal adjustments and refactoring lead to conflicts." "Google made changes to AOSP methods, affecting multiple code modules and functionalities."
- **Intrusive Modifications**. Downstream Android variants make intrusive modifications into upstream AOSP, which leads to frequent conflicts. *Example*: "Customized Android made intrusive modifications to AOSP’s modules. As Google continuously updated AOSP code, conflicts arose."
- **Unhealthy Architecture Design.** Bad architectural design and abstractions create tight coupling between downstream Android and upstream AOSP code, leading to recurring conflicts. *Example*: "The level of abstraction (decoupling the upstream and downstream code) is insufficient, rarely considering future requirements and change."
- **Inadequate Version Control Management.** Improper version management and branch synchronization issues cause conflicts. *Example*: "Our Android version X undergoes multiple merges with AOSP changes. We have made modifications to resolve conflicts in the previous merge. However, the next merge sometimes does not synchronize these latest changes, causing us to redo the work to resolve the conflicts that had been addressed in the last merge."

## 3. Conflict Resolution

►*Description and Relation to Android OS Upgrade Conflict*: The Conflict Resolution phase refers to the stage where developers, after conducting an in-depth analysis of the merge conflicts in the context of Android upgrades, design and implement solutions to resolve these conflicts. This typically includes evaluating the impact and feasibility of different solutions and selecting the best fix to maintain the integrity and stability of the code. During this phase, developers need to plan and implement effective conflict resolution strategies based on the conflict analysis, followed by necessary checks and commits after resolving the conflicts. Developers often use automated tools like Beyond Compare to assist in conflict resolution. For parts of the solution that are uncertain, developers should add TODO comments to be reviewed and resolved in subsequent workflows.

►*Challenges (Code, Description and Example)*:

- **Substantial Efforts on Conflict Analysis.** Analyzing the commit history of conflicting code is the most time-consuming in manual conflict resolution, followed by devising resolution solutions. *Example*: "Resolving conflicts requires reviewing the commit history of upstream and downstream, analyzing the causes of conflicts, which is the most time-consuming part."
- **Change Intent Inspection.** Due to the unfamiliarity with upstream AOSP and downstream commits, developers find it challenging to pinpoint underlying change intent. *Example*: "Due to my limited experience, I often do not fully understand the intended changes when resolving conflicts. As a result, I make direct modifications and refine them based on error messages."
- **Obstacles of Conflict Resolution.** Major factors impede effective conflict resolution, including the dependencies associated with conflicting code, the conflicts between old and new versions of downstream code, and the divergence between upstream and downstream changes. *Example*: "Google sometimes adds new parameters to certain methods, and these methods may be deeply nested in calls. In our custom-developed code, we sometimes call these methods, so we need to ensure that every method in the entire call chain passes this parameter when resolving conflicts."
- **Insufficient Conflict Resolution Tools.** Developers utilize tools to improve conflict resolution efficiency but note deficiencies in accuracy, performance, and usability of tools. *Example*: "The internal tool tends to freeze when loading a file with 300,000 lines of code."

## 4. Conflict Impact Analysis

►*Description and Relation to Android OS Upgrade Conflict*: Conflict impact analysis phase refers to the stage that after the code merge conflict is resolved, the developer analyzes the code modifications brought about by the conflict resolution to find out the scope of the code that may be affected and the potential problems caused to the subsequent phases. In this phase, the developer needs to, on the one hand, spatially identify the conflict-affected entities and file scopes through dependency analysis, and discover the program elements and functions affected by the conflict; on the other hand, temporally analyze the compilation, architectural, and feature issues that may be caused by the conflicting operations in the subsequent phases, and discover the semantic conflicts, such as build errors and test failures, so as to avoid delays in the progress of the conflict resolution and the workflow. 

►*Challenges (Code, Description and Example)*:

- **Impact Propagation via Dependencies.** From the code space perspective, conflict blocks often affect multiple files or even span across modules due to dependency propagation。*Example:* "Google's AOSP modifies a method in a long call chain that creates a conflict, and it's difficult to accurately eliminate the conflict if only that method is processed."
- **Impact across Design Boundaries.** From the space perspective, conflicts across the design boundary influence both upstream and downstream code。*Example:* "Google's self-research and downstream self-research code are coupled more, and the location of modifications is repeated, leading to repeated conflicts." "Upstream and downstream code logic coupling is too deep, once adjusted there will be conflicts."
- **Impact on Subsequent** **Workflow**. From the time perspective, improper conflict resolution will influence the subsequent phases during the Android Upgrade workflow, introducing semantic failures. *Example：*"The quality of conflict resolution phase deeply affects the quality of subsequent releases. I suggests the length of time spent arrangement to be: commit analysis>deconfliction>decompile; The status quo is: decompile>deconfliction>commit analysis."
